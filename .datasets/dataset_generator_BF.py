# -*- coding: utf-8 -*-
"""Dataset_generator_v4_BF.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CwR-2H9ShBnWz6YAeX48eorUaQvIRygi
"""

# Imports
import random
import networkx as nx
from networkx import Graph
from matplotlib import pyplot as plt
import pandas as pd
import numpy as np
import copy as copy
import multiprocessing
import itertools
import concurrent.futures
import threading
import pickle

# Function Definitions

def comm_cost(route, message_size):
    """Calculate the communication cost based on the route and message size.

    Args:
        route (list): List of nodes representing the route.
        message_size (int): Size of the message.

    Returns:
        tuple: Communication cost and modified message size.
    """
    hops = len(route) - 1
    bandwidth = 32  # Insert the bandwidth of your links here
    m_size = int(message_size / bandwidth)
    cost = hops * m_size
    return cost, m_size

def Extract_Highest_Priority(jobs, Ready_Jobs):
    """Extract the job with the highest priority from the ready jobs.

    Args:
        jobs (dict): Dictionary representing the jobs.
        Ready_Jobs (list): List of ready job indices.

    Returns:
        int: Index of the job with the highest priority.
    """
    priorities = []
    for i in range(len(Ready_Jobs)):
        prior = jobs[Ready_Jobs[i]]['priority']
        priorities.append(prior)
    min_value = min(priorities)
    idx = priorities.index(min_value)
    return Ready_Jobs[idx]

def traffic_control_reserve(Injection, path, message_size, path_cost, overwrite):
    """Simulate traffic control and reserve the required time slots for message transmission.

    Args:
        Injection (int): Injection time.
        path (list): List of nodes representing the path.
        message_size (int): Size of the message.
        path_cost (int): Cost of the path.
        overwrite (int): Flag to indicate if the reservation should overwrite existing slots.

    Returns:
        tuple: Updated start and end times for the current router.
    """
    Current_Router_start = Injection - message_size
    Current_Router_end = Injection + path_cost

    for count in range(len(path) - 1):
        Current_Router = [path[count], path[count + 1]]
        Current_Router_start = Current_Router_start + message_size
        Current_Router_end = Current_Router_start + message_size
        Current_Router_start, Current_Router_end = check_collision(Current_Router, Current_Router_start,
                                                                   Current_Router_end, overwrite)

    Delta_cost = Current_Router_end - (Injection + path_cost)
    return Delta_cost

def check_collision(Current_Router, Current_Router_start, Current_Router_end, overwrite):
    """Check for collisions and resolve them by modifying the start and end times of the current router.

    Args:
        Current_Router (list): List of nodes representing the current router.
        Current_Router_start (int): Current start time.
        Current_Router_end (int): Current end time.
        overwrite (int): Flag to indicate if the reservation should overwrite existing slots.

    Returns:
        tuple: Updated start and end times for the current router.
    """
    list_name = str(np.min(Current_Router)) + str(np.max(Current_Router))
    list_name = "cl_" + list_name

    current_list = globals()[list_name]

    for search in range(len(current_list)):
        while ((Current_Router_start >= current_list[search][0] and Current_Router_start < current_list[search][1]) or
               (Current_Router_end > current_list[search][0] and Current_Router_end <= current_list[search][1])):
            Current_Router_start = Current_Router_start + 1
            Current_Router_end = Current_Router_end + 1

    if overwrite == 1:
        globals()[list_name].append([Current_Router_start, Current_Router_end])

    return Current_Router_start, Current_Router_end

def find_path(connections, start_node, end_node):
    """Find the path between two nodes in a graph using Breadth-First Search.

    Args:
        connections (list): List of tuples representing the graph connections.
        start_node (int): Start node index.
        end_node (int): End node index.

    Returns:
        list: List of nodes representing the path from start to end.
    """
    nodes = set()
    for connection in connections:
        nodes.add(connection[0])
        nodes.add(connection[1])

    adjacency_list = {}
    for connection in connections:
        node1 = connection[0]
        node2 = connection[1]
        if node1 not in adjacency_list:
            adjacency_list[node1] = []
        if node2 not in adjacency_list:
            adjacency_list[node2] = []
        adjacency_list[node1].append(node2)
        adjacency_list[node2].append(node1)

    visited = set()
    queue = [[start_node]]
    while queue:
        path = queue.pop(0)
        node = path[-1]
        if node == end_node:
            return path
        elif node not in visited:
            for neighbor in adjacency_list.get(node, []):
                new_path = list(path)
                new_path.append(neighbor)
                queue.append(new_path)
            visited.add(node)
    return None

def dict_to_dataframe(dictionary):
    """Convert a dictionary to a Pandas DataFrame.

    Args:
        dictionary (dict): Dictionary to be converted.

    Returns:
        DataFrame: Converted DataFrame.
    """
    df = pd.DataFrame()
    for key, attributes in dictionary.items():
        attr_df = pd.DataFrame.from_dict(attributes, orient='index').transpose()
        df = pd.concat([df, attr_df], ignore_index=True)
    return df

def Schedule(jobs, routes, end_systems, messages, links):
    """Schedule the jobs and calculate the makespan.

    Args:
        jobs (dict): Dictionary representing the jobs.
        routes (dict): Dictionary representing the routes.
        end_systems (list): List of end systems.
        messages (dict): Dictionary representing the messages.
        links (list): List of links.

    Returns:
        int: Makespan of the schedule.
    """
    Ready_Jobs = []
    Finished_jobs = []

    processor_endTime = [0 for j in range(len(end_systems))]

    for i in range(len(jobs)):
        if jobs[i]['parents'] == []:
            Ready_Jobs.append(i)

    while Ready_Jobs != []:
        Job = Extract_Highest_Priority(jobs, Ready_Jobs)
        End_system = jobs[Job]['end_system']
        execution_time = jobs[Job]['wcet']

        parents_job = jobs[Job]['parents']
        parents_end_times = [jobs[parent]['end_time'] for parent in parents_job]
        parents_end_times.append(processor_endTime[End_system - 1])
        maxi = max(parents_end_times)
        jobs[Job]["start_time"] = maxi
        processor_endTime[End_system - 1] = maxi + execution_time
        jobs[Job]["end_time"] = processor_endTime[End_system - 1]

        Finished_jobs.append(Job)
        Ready_Jobs.remove(Job)

        children = jobs[Job]['children']

        for child in children:
            if set(jobs[child]['parents']).issubset(Finished_jobs):
                Ready_Jobs.append(child)
                Ready_Jobs = list(set(Ready_Jobs))

    for i in range(len(links)):
        name = "cl_" + str(links[i][0]) + str(links[i][1])
        globals()[name] = []

    Msg_counter = 0
    for i in Finished_jobs:
        processor_sender = jobs[i]['end_system']
        Msg_Size = jobs[i]['message_size']
        children = jobs[i]['children']
        Injection_time = jobs[i]['end_time']
        for j in children:
            processor_receiver = jobs[j]['end_system']
            if processor_sender == processor_receiver:
                Msg_Size = 0
                Route = []
                messages[Msg_counter]['route'] = []
                messages[Msg_counter]['parent'] = i
                messages[Msg_counter]['child'] = j
                messages[Msg_counter]['start_time'] = Injection_time
                messages[Msg_counter]['finish_time'] = Injection_time
                messages[Msg_counter]['sender'] = processor_sender
                messages[Msg_counter]['receiver'] = processor_receiver
                Msg_counter += 1
            else:
                Route = routes.get((processor_sender, processor_receiver))
                Cost, msize = comm_cost(Route, Msg_Size)
                col_costs = traffic_control_reserve(Injection_time, Route, msize, Cost, 1)
                comm_costs = Cost + col_costs
                messages[Msg_counter]['start_time'] = Injection_time
                messages[Msg_counter]['finish_time'] = Injection_time + comm_costs
                messages[Msg_counter]['parent'] = i
                messages[Msg_counter]['child'] = j
                messages[Msg_counter]['route'] = Route
                messages[Msg_counter]['sender'] = processor_sender
                messages[Msg_counter]['receiver'] = processor_receiver
                if jobs[j]['start_time'] < messages[Msg_counter]['finish_time']:
                    starting_time = jobs[j]['start_time']
                    ending_time = jobs[j]['end_time']
                    diff = messages[Msg_counter]['finish_time'] - starting_time
                    jobs[j]['start_time'] = starting_time + diff
                    jobs[j]['end_time'] = ending_time + diff
                Msg_counter += 1

    Makespan = max(jobs[j]['end_time'] for j in range(len(jobs)))

    return Makespan

def calculate_makespan(args):
    """Calculate the makespan for a given set of priority and processor assignments.

    Args:
        args (tuple): Tuple containing priority_assignment, processor_assignment, and jobs.

    Returns:
        None: The best solution is updated in-place.
    """
    priority_assignment, processor_assignment, jobs = args
    for i in range(len(jobs)):
        jobs[i]['priority'] = priority_assignment[i]
        jobs[i]['end_system'] = processor_assignment[i]
    current_solution = jobs.copy()
    current_makespan = Schedule(jobs, routes, end_systems, messages, Links)
    with lock:
        if current_makespan < best_solution[0]:
            best_solution[0] = current_makespan
            best_solution[1] = current_solution

# Generate application and platform model

number_of_sample = 1000
sample_no = 0

# Create your Platform model

# Define parameters
num_of_processors = 4
num_of_routers = 2
Links = [(1, 5), (2, 5), (5, 6), (3, 6), (4, 6)]  # define your connection (manually)
end_systems = [i + 1 for i in range(num_of_processors)]
routers = [i + num_of_processors + 1 for i in range(num_of_routers)]

# Create the routes dictionary
routes = {}
for i in range(num_of_processors):
    for j in range(num_of_processors):
        if i != j:
            sender = end_systems[i]
            receiver = end_systems[j]
            route = find_path(Links, sender, receiver)
            routes[(sender, receiver)] = route

# Draw a random acyclic Directed graph for Jobs

num_jobs = 5  # select the number of jobs

while sample_no != number_of_sample:
    G = nx.gnp_random_graph(num_jobs, 0.25, directed=True)
    DAG = nx.DiGraph([(u, v) for (u, v) in G.edges() if u < v])

    Edge_list = [e for e in DAG.edges]

    min_wcet = 1  # Minimum Worst Case execution time for jobs
    max_wcet = 25  # Maximum Worst Case execution time for jobs
    min_msg_sizes = 16  # Minimum Message Size
    max_msg_sizes = 100  # Maximum Message Size

    wcets = [random.randint(min_wcet, max_wcet) for _ in range(num_jobs)]
    msg_sizes = [random.randint(min_msg_sizes, max_msg_sizes) for _ in range(num_jobs)]

    parents = [[] for _ in range(num_jobs)]
    children = [[] for _ in range(num_jobs)]

    for i in range(len(Edge_list)):
        parent = Edge_list[i][0]
        child = Edge_list[i][1]
        parents[child].append(parent)
        children[parent].append(child)

    jobs = {i: {"wcet": wcets[i],
                "message_size": msg_sizes[i],
                "parents": parents[i],
                "children": children[i],
                "start_time": 0,
                "end_time": 0,
                "priority": 0,
                "end_system": 0} for i in range(num_jobs)}

    messages = {i: {"parent": 0,
                    "child": 0,
                    "sender": 0,
                    "receiver": 0,
                    "route": [],
                    "start_time": 0,
                    "finish_time": 0} for i in range(len(Edge_list))}

    generate_solution = 0

    while generate_solution == 0:
        priority_space = list(range(1, num_jobs + 1))
        lock = threading.Lock()
        best_solution = [99999, None]

        num_threads = 1000

        with concurrent.futures.ThreadPoolExecutor(max_workers=num_threads) as executor:
            processor_space = list(itertools.product(end_systems, repeat=num_jobs))

            for priority_assignment in itertools.permutations(priority_space):
                for processor_assignment in processor_space:
                    executor.submit(calculate_makespan, (priority_assignment, processor_assignment, jobs))

    name = "/content/drive/MyDrive/Datasets/5_jobs_BF/"
    name = name + "sample_" + str(sample_no) + ".p"
    sample_no += 1
    pickle.dump(best_solution[1], open(name, "wb"))
    generate_solution = 1
    print(sample_no)
